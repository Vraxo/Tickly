// * File: MainPage.xaml---
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:vm="clr-namespace:Tickly.ViewModels"
             xmlns:models="clr-namespace:Tickly.Models"
             xmlns:converters="clr-namespace:Tickly.Converters"
             x:Class="Tickly.MainPage"
             BackgroundColor="Black"
             Title="Tickly Tasks">

    <ContentPage.BindingContext>
        <vm:MainViewModel />
    </ContentPage.BindingContext>

    <!-- Use Shell.TitleView to place Title and Picker side-by-side -->
    <Shell.TitleView>
        <Grid ColumnDefinitions="*, Auto" VerticalOptions="FillAndExpand" Margin="0,0,10,0">
            <Label Grid.Column="0"
                   Text="Tickly Tasks"
                   TextColor="{AppThemeBinding Light=Black, Dark=White}"
                   FontSize="18"
                   FontAttributes="Bold"
                   VerticalOptions="Center"
                   HorizontalOptions="Start"
                   Margin="10,0,0,0"/>

            <!-- Picker placed directly in TitleView Grid -->
            <Picker Grid.Column="1"
                    ItemsSource="{Binding SortOptionsDisplay}"
                    SelectedItem="{Binding SelectedSortOption}"
                    BackgroundColor="Black"
                TextColor="WhiteSmoke"
                    FontSize="Small"
                    HorizontalOptions="End"
                    VerticalOptions="Center"
                    MinimumWidthRequest="180"
                    Margin="0,0,5,0"/>
        </Grid>
    </Shell.TitleView>


    <ContentPage.Resources>
        <ResourceDictionary>
            <converters:PriorityToColorConverter x:Key="PriorityColorConverter" />
            <converters:TaskTimeToStringConverter x:Key="TaskTimeConverter" />
            <converters:InverseBooleanConverter x:Key="InverseBooleanConverter" />

            <Style TargetType="Frame" x:Key="PriorityIndicatorFrameStyle">
                <Setter Property="HeightRequest" Value="12"/>
                <Setter Property="WidthRequest" Value="12"/>
                <Setter Property="CornerRadius" Value="6"/>
                <Setter Property="BackgroundColor" Value="{Binding Priority, Converter={StaticResource PriorityColorConverter}}"/>
                <Setter Property="VerticalOptions" Value="Center"/>
                <Setter Property="HorizontalOptions" Value="Center"/>
                <Setter Property="BorderColor" Value="Transparent"/>
                <Setter Property="Padding" Value="0"/>
                <Setter Property="Margin" Value="0,5,0,0"/>
            </Style>
            <Style TargetType="Label" x:Key="TaskTitleLabelStyle">
                <Setter Property="TextColor" Value="{AppThemeBinding Light=Black, Dark=White}"/>
                <Setter Property="FontSize" Value="16"/>
                <Setter Property="FontAttributes" Value="Bold"/>
                <Setter Property="VerticalOptions" Value="Center"/>
            </Style>
            <Style TargetType="Label" x:Key="TaskTimeLabelStyle">
                <Setter Property="TextColor" Value="Gray"/>
                <Setter Property="FontSize" Value="12"/>
                <Setter Property="VerticalOptions" Value="Center"/>
            </Style>
            <Style TargetType="StackLayout" x:Key="EmptyViewLayoutStyle">
                <Setter Property="VerticalOptions" Value="Center"/>
                <Setter Property="HorizontalOptions" Value="Center"/>
                <Setter Property="Padding" Value="20"/>
                <Setter Property="Spacing" Value="5"/>
            </Style>
            <Style TargetType="Label" x:Key="EmptyViewLabelStyle">
                <Setter Property="TextColor" Value="Gray"/>
                <Setter Property="HorizontalTextAlignment" Value="Center"/>
            </Style>
            <Style TargetType="Button" x:Key="AddButtonStyle">
                <Setter Property="Text" Value="+"/>
                <Setter Property="FontSize" Value="24"/>
                <Setter Property="FontAttributes" Value="Bold"/>
                <Setter Property="TextColor" Value="{AppThemeBinding Light=White, Dark=Black}"/>
                <Setter Property="BackgroundColor" Value="{StaticResource Primary}"/>
                <Setter Property="CornerRadius" Value="28"/>
                <Setter Property="HeightRequest" Value="56"/>
                <Setter Property="WidthRequest" Value="56"/>
                <Setter Property="HorizontalOptions" Value="End"/>
                <Setter Property="VerticalOptions" Value="End"/>
                <Setter Property="Margin" Value="20"/>
                <Setter Property="SemanticProperties.Hint" Value="Add a new task"/>
            </Style>

            <!-- General Picker Style REMOVED -->

        </ResourceDictionary>
    </ContentPage.Resources>

    <!-- Main Grid Layout - Single Row -->
    <Grid RowDefinitions="*" ColumnDefinitions="*">

        <!-- Picker REMOVED from here -->

        <!-- Task List - Row 0 -->
        <CollectionView Grid.Row="0" Grid.Column="0"
                        ItemsSource="{Binding Tasks}"
                        CanReorderItems="True"
                        Margin="15,10,15,10"
                        SelectionMode="None">

            <CollectionView.ItemTemplate>
                <DataTemplate x:DataType="models:TaskItem">
                    <Grid Padding="10, 8"
                          Opacity="{Binding IsFadingOut, Converter={StaticResource InverseBooleanConverter}}">
                        <Grid ColumnSpacing="10">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto" />
                                <ColumnDefinition Width="*" />
                                <ColumnDefinition Width="Auto" />
                            </Grid.ColumnDefinitions>
                            <Frame Grid.Column="0" Style="{StaticResource PriorityIndicatorFrameStyle}"/>
                            <VerticalStackLayout Grid.Column="1" Spacing="2" VerticalOptions="Center">
                                <VerticalStackLayout.GestureRecognizers>
                                    <TapGestureRecognizer
                                        Command="{Binding Source={RelativeSource AncestorType={x:Type vm:MainViewModel}}, Path=NavigateToEditPageCommand}"
                                        CommandParameter="{Binding .}" />
                                </VerticalStackLayout.GestureRecognizers>
                                <Label Text="{Binding Title}" Style="{StaticResource TaskTitleLabelStyle}" />
                                <Label Text="{Binding ., Converter={StaticResource TaskTimeConverter}}" Style="{StaticResource TaskTimeLabelStyle}" />
                            </VerticalStackLayout>

                            <!-- Grid for the Check Circle (MARK TASK DONE AREA) -->
                            <Grid Grid.Column="2"
                                  VerticalOptions="Center"
                                  HorizontalOptions="Center"
                                  Margin="5,0,0,0"
                                  Padding="5">
                                <!-- FIX: Add Transparent Background to Grid -->
                                <Grid.Background>
                                    <SolidColorBrush Color="Transparent"/>
                                </Grid.Background>
                                <Grid.GestureRecognizers>
                                    <TapGestureRecognizer
                                        Command="{Binding Source={RelativeSource AncestorType={x:Type vm:MainViewModel}}, Path=MarkTaskDoneCommand}"
                                        CommandParameter="{Binding .}"/>
                                </Grid.GestureRecognizers>
                                <!-- FIX: Make Border InputTransparent -->
                                <Border Stroke="{AppThemeBinding Light=Gray, Dark=LightGray}"
                                        StrokeThickness="2"
                                        HeightRequest="24"
                                        WidthRequest="24"
                                        VerticalOptions="Center"
                                        HorizontalOptions="Center"
                                        InputTransparent="True">
                                    <Border.StrokeShape>
                                        <Ellipse/>
                                    </Border.StrokeShape>
                                </Border>
                            </Grid>
                            <!-- End of Check Circle Grid -->

                        </Grid>
                    </Grid>
                </DataTemplate>
            </CollectionView.ItemTemplate>

            <CollectionView.EmptyView>
                <StackLayout Style="{StaticResource EmptyViewLayoutStyle}">
                    <Label Text="No tasks yet!" Style="{StaticResource EmptyViewLabelStyle}" FontSize="16"/>
                    <Label Text="Click the '+' button to add one." Style="{StaticResource EmptyViewLabelStyle}" FontSize="14"/>
                </StackLayout>
            </CollectionView.EmptyView>

        </CollectionView>

        <!-- Add Button - Row 0 -->
        <Button Grid.Row="0" Grid.Column="0"
                Style="{StaticResource AddButtonStyle}"
                Command="{Binding NavigateToAddPageCommand}"/>

    </Grid>

</ContentPage>

--------------------------------------------------------------------------------

// * File: MainPage.xaml.cs---
// File: MainPage.xaml.cs
namespace Tickly;

public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
}

--------------------------------------------------------------------------------

// * File: Converters\InverseBooleanConverter.cs---
using System.Globalization;

namespace Tickly.Converters;

public class InverseBooleanConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture) => value is bool b && !b;
    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) => value is bool b && !b;
}

--------------------------------------------------------------------------------

// * File: Converters\PriorityToColorConverter.cs---
using System.Globalization;
using Tickly.Models;

namespace Tickly.Converters;

public class PriorityToColorConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is TaskPriority priority)
        {
            return priority switch
            {
                TaskPriority.High => Colors.Red,
                TaskPriority.Medium => Colors.Orange,
                TaskPriority.Low => Colors.LimeGreen,
                _ => Colors.Gray,
            };
        }

        return Colors.Gray;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

--------------------------------------------------------------------------------

// * File: Converters\TaskTimeToStringConverter.cs---
using System.Diagnostics;
using System.Globalization;
using Tickly.Models;
using Tickly.Services;

namespace Tickly.Converters;

public class TaskTimeToStringConverter : IValueConverter
{
    private static readonly string[] PersianAbbreviatedMonthNames =
    [
        "", "فرور", "اردی", "خرد", "تیر", "مرد", "شهر", "مهر", "آبا", "آذر", "دی", "بهم", "اسف"
    ];

    private const string NoDateString = "No date";
    private const string AnyTimeString = "Any time";
    private const string DateErrorString = "Date Error";
    private const string TodayString = "Today";
    private const string TomorrowString = "Tomorrow";
    private const string UnknownDueDateString = "Unknown";
    private const string DefaultGregorianDateFormat = "ddd, dd MMM yyyy";
    private const string ShortGregorianDateFormat = "dd MMM";
    private const string DayAndShortGregorianDateFormat = "ddd, dd MMM";
    private const string FallbackIsoDateFormat = "yyyy-MM-dd";
    private const string RepeatingPrefix = "Repeating";
    private const string DailyRepetition = "Daily";
    private const string AlternateDayRepetition = "Every other day";
    private const string WeeklyRepetitionFormat = "Weekly on {0}";
    private const string DuePrefix = "due";

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not TaskItem task)
        {
            return string.Empty;
        }

        CalendarSystemType calendarSystem = AppSettings.SelectedCalendarSystem;
        CultureInfo formatCulture = GetFormatCulture(calendarSystem);

        try
        {
            return FormatTaskTime(task, calendarSystem, formatCulture);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error in TaskTimeToStringConverter for task '{task.Title}': {ex.Message}");
            return DateErrorString;
        }
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }

    private static CultureInfo GetFormatCulture(CalendarSystemType calendarSystem)
    {
        return calendarSystem == CalendarSystemType.Persian
            ? new("fa-IR")
            : CultureInfo.InvariantCulture;
    }

    private static string FormatTaskTime(TaskItem task, CalendarSystemType calendarSystem, CultureInfo formatCulture)
    {
        return task.TimeType switch
        {
            TaskTimeType.SpecificDate => FormatSpecificDateTask(task, calendarSystem, formatCulture),
            TaskTimeType.Repeating => FormatRepeatingTask(task, calendarSystem, formatCulture),
            TaskTimeType.None => AnyTimeString,
            _ => AnyTimeString,
        };
    }

    private static string FormatSpecificDateTask(TaskItem task, CalendarSystemType calendarSystem, CultureInfo formatCulture)
    {
        return task.DueDate is null
            ? NoDateString
            : FormatDate(task.DueDate.Value, calendarSystem, formatCulture, DefaultGregorianDateFormat);
    }

    private static string FormatRepeatingTask(TaskItem task, CalendarSystemType calendarSystem, CultureInfo formatCulture)
    {
        string repetition = GetRepetitionString(task, formatCulture);
        string nextDueDateString = task.DueDate.HasValue
            ? FormatDate(task.DueDate.Value, calendarSystem, formatCulture, DayAndShortGregorianDateFormat)
            : UnknownDueDateString;

        return $"{repetition}, {DuePrefix} {nextDueDateString}";
    }

    private static string GetRepetitionString(TaskItem task, CultureInfo formatCulture)
    {
        return task.RepetitionType switch
        {
            TaskRepetitionType.Daily => DailyRepetition,
            TaskRepetitionType.AlternateDay => AlternateDayRepetition,
            TaskRepetitionType.Weekly => string.Format(formatCulture, WeeklyRepetitionFormat, GetDayName(task.RepetitionDayOfWeek, formatCulture)),
            _ => RepeatingPrefix
        };
    }

    private static string FormatDate(DateTime date, CalendarSystemType system, CultureInfo formatCulture, string gregorianFormat)
    {
        string? specialDay = GetSpecialDayString(date.Date);

        if (specialDay is not null && (gregorianFormat == DefaultGregorianDateFormat || gregorianFormat == DayAndShortGregorianDateFormat || gregorianFormat == ShortGregorianDateFormat))
        {
            return specialDay;
        }

        return system == CalendarSystemType.Persian
            ? FormatPersianDate(date, formatCulture, gregorianFormat)
            : FormatGregorianDate(date, formatCulture, gregorianFormat);
    }

    private static string? GetSpecialDayString(DateTime date)
    {
        var today = DateTime.Today;
        DateTime tomorrow = today.AddDays(1);

        if (date == today)
        {
            return TodayString;
        }

        return date == tomorrow 
            ? TomorrowString
            : null;
    }

    private static string FormatPersianDate(DateTime date, CultureInfo formatCulture, string gregorianFormat)
    {
        try
        {
            PersianCalendar persianCalendar = new();
            int year = persianCalendar.GetYear(date);
            int month = persianCalendar.GetMonth(date);
            int day = persianCalendar.GetDayOfMonth(date);
            string dayName = formatCulture.DateTimeFormat.GetAbbreviatedDayName(persianCalendar.GetDayOfWeek(date));

            string monthName = month >= 1 && month <= 12
                ? PersianAbbreviatedMonthNames[month]
                : "?";

            return gregorianFormat switch
            {
                DefaultGregorianDateFormat => $"{dayName}، {day:00} {monthName} {year}",
                ShortGregorianDateFormat => $"{day:00} {monthName}",
                DayAndShortGregorianDateFormat => $"{dayName}، {day:00} {monthName}",
                _ => FallbackToGregorianFormat(date, formatCulture, gregorianFormat, "Persian")
            };
        }
        catch (ArgumentOutOfRangeException argEx)
        {
            Debug.WriteLine($"Persian calendar range error for date {date:O}: {argEx.Message}");
            return date.ToString(FallbackIsoDateFormat);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Unexpected Persian date formatting error: {ex.Message}");
            return date.ToString(FallbackIsoDateFormat);
        }
    }

    private static string FormatGregorianDate(DateTime date, CultureInfo formatCulture, string gregorianFormat)
    {
        try
        {
            return date.ToString(gregorianFormat, formatCulture);
        }
        catch (FormatException formatEx)
        {
            Debug.WriteLine($"Gregorian date format error for date {date:O} with format '{gregorianFormat}': {formatEx.Message}");
            return date.ToString(FallbackIsoDateFormat);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Unexpected Gregorian date formatting error: {ex.Message}");
            return date.ToString(FallbackIsoDateFormat);
        }
    }

    private static string FallbackToGregorianFormat(DateTime date, CultureInfo formatCulture, string requestedFormat, string calendarTypeName)
    {
        Debug.WriteLine($"FormatDate ({calendarTypeName}): Fallback standard formatting for requested format '{requestedFormat}'. May show Gregorian month names.");
        return date.ToString(requestedFormat, formatCulture);
    }

    private static string GetDayName(DayOfWeek? dayOfWeek, CultureInfo formatCulture)
    {
        if (dayOfWeek is null)
        {
            return string.Empty;
        }

        try
        {
            return formatCulture.DateTimeFormat.GetDayName(dayOfWeek.Value);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error getting day name for {dayOfWeek.Value} with culture {formatCulture.Name}: {ex.Message}");
            return dayOfWeek.Value.ToString();
        }
    }
}

--------------------------------------------------------------------------------

// * File: Messages\CalendarSettingsChangedMessage.cs---
// Messages/CalendarSettingChangedMessage.cs
using CommunityToolkit.Mvvm.Messaging.Messages;

namespace Tickly.Messages;

/// <summary>
/// A simple message indicating that the calendar system setting has changed.
/// </summary>
public class CalendarSettingChangedMessage : ValueChangedMessage<bool> // Value isn't strictly needed, but fits pattern
{
    // We don't really need to pass a value, but ValueChangedMessage requires one.
    // We can just pass true to indicate a change occurred.
    public CalendarSettingChangedMessage() : base(true)
    {
    }
}

--------------------------------------------------------------------------------

// * File: Messages\TaskMessages.cs---
// File: Messages/TaskMessages.cs (Add to this existing file)
using CommunityToolkit.Mvvm.Messaging.Messages;
using Tickly.Models;
using System; // Needed for Guid

namespace Tickly.Messages;

// Existing AddTaskMessage
public class AddTaskMessage : ValueChangedMessage<TaskItem>
{
    public AddTaskMessage(TaskItem value) : base(value) { }
}

// Existing UpdateTaskMessage
public class UpdateTaskMessage : ValueChangedMessage<TaskItem>
{
    public UpdateTaskMessage(TaskItem value) : base(value) { }
}

// Existing DeleteTaskMessage
public class DeleteTaskMessage : ValueChangedMessage<Guid>
{
    public DeleteTaskMessage(Guid taskId) : base(taskId) { }
}

// *** NEW MESSAGE ***
/// <summary>
/// Signals that the underlying task data source may have changed (e.g., after import)
/// and the main view should reload its tasks.
/// </summary>
public class TasksReloadRequestedMessage : RequestMessage<bool> // Can just use RequestMessage
{
    // No specific data needed, just the signal
}
// *** END NEW MESSAGE ***

--------------------------------------------------------------------------------

// * File: Models\Enums.cs---
// File: Models\Enums.cs
namespace Tickly.Models;

public enum TaskPriority
{
    High,   // Red
    Medium, // Orange
    Low     // Green
}

public enum TaskTimeType
{
    None,         // One-time, any time
    SpecificDate, // Specific date
    Repeating     // Daily, Alternate, Weekly
}

public enum TaskRepetitionType
{
    Daily,
    AlternateDay, // Every other day from the start date
    Weekly
}

// *** ADDED ENUM ***
public enum SortOrderType
{
    Manual, // Default order as saved/reordered by user
    PriorityHighFirst, // High -> Low -> Title
    PriorityLowFirst // Low -> High -> Title
}
// *** END ADDED ENUM ***

--------------------------------------------------------------------------------

// * File: Models\Settings.cs---
// Models/Settings.cs (New File or add to existing Models)
namespace Tickly.Models;

public enum CalendarSystemType
{
    Gregorian,
    Persian
}

--------------------------------------------------------------------------------

// * File: Models\TaskItem.cs---
// Models/TaskItem.cs
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using Tickly.Models; // Make sure enum namespace is referenced if separate

namespace Tickly.Models;

public partial class TaskItem : ObservableObject
{
    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private string _title;

    [ObservableProperty]
    private TaskPriority _priority;

    [ObservableProperty]
    private TaskTimeType _timeType;

    [ObservableProperty]
    private DateTime? _dueDate; // Base/current due date or start date for repeating

    [ObservableProperty]
    private TaskRepetitionType? _repetitionType;

    [ObservableProperty]
    private DayOfWeek? _repetitionDayOfWeek;

    [ObservableProperty]
    private int _order;

    // --- NEW Property for Animation ---
    [ObservableProperty]
    private bool _isFadingOut; // Flag to trigger fade-out animation before removal

    // Parameterless constructor for JSON deserialization
    public TaskItem()
    {
        Id = Guid.NewGuid();
        Title = string.Empty;
        // Default TimeType is TaskTimeType.None (0)
        IsFadingOut = false; // Default state
    }

    // Full constructor
    public TaskItem(
        string title,
        TaskPriority priority,
        TaskTimeType timeType,
        DateTime? dueDate,
        TaskRepetitionType? repetitionType,
        DayOfWeek? repetitionDayOfWeek,
        int order = 0)
    {
        Id = Guid.NewGuid();
        Title = title;
        Priority = priority;
        TimeType = timeType;
        DueDate = dueDate;
        RepetitionType = repetitionType;
        RepetitionDayOfWeek = repetitionDayOfWeek;
        Order = order;
        IsFadingOut = false; // Default state
    }
}

--------------------------------------------------------------------------------

// * File: Services\AppSettings.cs---
// Services/AppSettings.cs
using Microsoft.Maui.Storage; // Required for Preferences
using System.Diagnostics;
using Tickly.Models;

namespace Tickly.Services
{
    public static class AppSettings
    {
        // Key for storing the setting
        public const string CalendarSystemKey = "CalendarSystemPreference";

        // Backing field - Now initialized by static constructor
        private static CalendarSystemType _selectedCalendarSystem;

        // --- Static Constructor ---
        // This runs automatically the first time the AppSettings class is accessed.
        static AppSettings()
        {
            // Load from Preferences, default to Gregorian (0) if not found
            int storedValue = Preferences.Get(CalendarSystemKey, (int)CalendarSystemType.Gregorian);
            _selectedCalendarSystem = (CalendarSystemType)storedValue; // Set the backing field directly
            Debug.WriteLine($"AppSettings (Static Constructor): Initialized CalendarSystem to {_selectedCalendarSystem} from Preferences.");
        }
        // --- End Static Constructor ---

        // Public property to access the setting
        public static CalendarSystemType SelectedCalendarSystem
        {
            get => _selectedCalendarSystem;
            set
            {
                if (_selectedCalendarSystem != value)
                {
                    _selectedCalendarSystem = value; // Update backing field
                    // Preferences are saved by SettingsViewModel when user makes changes
                    Debug.WriteLine($"AppSettings: CalendarSystem changed to {value} (will be saved by SettingsViewModel).");
                    // Optionally raise an event if needed for non-UI immediate updates
                    // SettingsChanged?.Invoke(null, EventArgs.Empty);
                }
            }
        }

        // Optional: Event for real-time updates elsewhere if needed
        // public static event EventHandler SettingsChanged;
    }
}

--------------------------------------------------------------------------------

// * File: Utils\DateUtils.cs---
// Utils/DateUtils.cs
using System;

namespace Tickly.Utils;

public static class DateUtils
{
    /// <summary>
    /// Calculates the next occurrence of a specific DayOfWeek,
    /// starting from (and including) the given base date.
    /// </summary>
    /// <param name="baseDate">The date to start searching from.</param>
    /// <param name="targetDay">The desired DayOfWeek.</param>
    /// <returns>The DateTime of the next occurrence.</returns>
    public static DateTime GetNextWeekday(DateTime baseDate, DayOfWeek targetDay)
    {
        // Start checking from the base date itself
        DateTime nextDate = baseDate.Date; // Ensure we work with Date part only
        while (nextDate.DayOfWeek != targetDay)
        {
            nextDate = nextDate.AddDays(1);
        }
        return nextDate;
    }

    /// <summary>
    /// Calculates the next due date for a repeating task based on its
    /// current due date and repetition settings.
    /// </summary>
    public static DateTime? CalculateNextDueDate(Models.TaskItem task)
    {
        DateTime baseDate = task.DueDate ?? DateTime.Today; // Base calculation on current due date or today

        switch (task.RepetitionType)
        {
            case Models.TaskRepetitionType.Daily:
                return baseDate.AddDays(1).Date; // Ensure time is stripped

            case Models.TaskRepetitionType.AlternateDay:
                return baseDate.AddDays(2).Date; // Ensure time is stripped

            case Models.TaskRepetitionType.Weekly:
                if (task.RepetitionDayOfWeek.HasValue)
                {
                    // Find the next occurrence strictly *after* the current base date
                    DateTime nextDate = baseDate.AddDays(1);
                    return GetNextWeekday(nextDate, task.RepetitionDayOfWeek.Value);
                }
                else
                {
                    // Fallback: if no specific day, just add 7 days (unlikely with UI)
                    return baseDate.AddDays(7).Date;
                }

            default:
                return null; // Unknown repetition type
        }
    }
}

--------------------------------------------------------------------------------

// * File: ViewModels\MainViewModel.cs---
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Maui.ApplicationModel; // Needed for MainThread
using Microsoft.Maui.Controls; // Needed for Shell
using Tickly.Messages;
using Tickly.Models;
using Tickly.Views;
using Tickly.Utils; // Needed for DateUtils

namespace Tickly.ViewModels;

public partial class MainViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableCollection<TaskItem> _tasks;

    private readonly string _filePath;
    private bool _isSaving = false;
    private readonly object _saveLock = new object();

    private SortOrderType _currentSortOrder = SortOrderType.Manual;

    [ObservableProperty]
    private List<string> _sortOptionsDisplay;

    private string _selectedSortOption;
    public string SelectedSortOption
    {
        get => _selectedSortOption;
        set
        {
            if (SetProperty(ref _selectedSortOption, value))
            {
                ApplySortOrderCommand.Execute(null);
            }
        }
    }


    public MainViewModel()
    {
        _filePath = Path.Combine(FileSystem.AppDataDirectory, "tasks.json");
        _tasks = new ObservableCollection<TaskItem>();

        SortOptionsDisplay = new List<string>
        {
            "Manual Order",
            "Priority (High First)",
            "Priority (Low First)"
        };
        _selectedSortOption = SortOptionsDisplay[0];

        _ = LoadTasksAsync();

        WeakReferenceMessenger.Default.Register<AddTaskMessage>(this, (r, m) => HandleAddTask(m.Value));
        WeakReferenceMessenger.Default.Register<UpdateTaskMessage>(this, (r, m) => HandleUpdateTask(m.Value));
        WeakReferenceMessenger.Default.Register<DeleteTaskMessage>(this, (r, m) => HandleDeleteTask(m.Value));
        WeakReferenceMessenger.Default.Register<CalendarSettingChangedMessage>(this, (r, m) => HandleCalendarSettingChanged());
        WeakReferenceMessenger.Default.Register<TasksReloadRequestedMessage>(this, async (r, m) => await HandleTasksReloadRequested());
    }


    [RelayCommand]
    private async Task NavigateToAddPage()
    {
        try { await Shell.Current.GoToAsync(nameof(AddTaskPopupPage), true, new Dictionary<string, object> { { "TaskToEdit", null } }); }
        catch (Exception ex) { Debug.WriteLine($"Error navigating to add page: {ex.Message}"); }
    }

    [RelayCommand]
    private async Task NavigateToEditPage(TaskItem? taskToEdit)
    {
        if (taskToEdit == null) { return; }
        try
        {
            var navigationParameter = new Dictionary<string, object> { { "TaskToEdit", taskToEdit } };
            await Shell.Current.GoToAsync(nameof(AddTaskPopupPage), true, navigationParameter);
        }
        catch (Exception ex) { Debug.WriteLine($"Error navigating to edit page for task {taskToEdit.Id}: {ex.Message}"); }
    }

    [RelayCommand]
    private async Task LoadTasksAsync()
    {
        lock (_saveLock) { if (_isSaving) { return; } }
        Debug.WriteLine($"LoadTasksAsync: Attempting to load tasks from: {_filePath}");
        bool wasSubscribed = false;
        try { Tasks.CollectionChanged -= Tasks_CollectionChanged; wasSubscribed = true; } catch { }

        bool changesMade = false; // Flag to check if any task dates were adjusted

        try
        {
            List<TaskItem> loadedTasks = new List<TaskItem>();
            if (File.Exists(_filePath))
            {
                string json = await File.ReadAllTextAsync(_filePath);
                if (!string.IsNullOrWhiteSpace(json))
                {
                    try { loadedTasks = JsonSerializer.Deserialize<List<TaskItem>>(json) ?? new List<TaskItem>(); }
                    catch (JsonException jsonEx) { Debug.WriteLine($"LoadTasksAsync: Error deserializing tasks JSON: {jsonEx.Message}"); }
                }
            }

            // --- Adjust Overdue Repeating Tasks ---
            DateTime today = DateTime.Today;
            foreach (var task in loadedTasks)
            {
                if (task.TimeType == TaskTimeType.Repeating && task.DueDate.HasValue && task.DueDate.Value.Date < today)
                {
                    DateTime originalDueDate = task.DueDate.Value.Date;
                    DateTime nextValidDueDate = originalDueDate; // Start with original

                    switch (task.RepetitionType)
                    {
                        case TaskRepetitionType.Daily:
                            nextValidDueDate = today;
                            break;

                        case TaskRepetitionType.AlternateDay:
                            // Calculate how many due dates were missed
                            double daysDifference = (today - originalDueDate).TotalDays;
                            // If an even number of days passed, today is a due date
                            // If an odd number, tomorrow is the next due date
                            if (daysDifference % 2 == 0)
                            {
                                nextValidDueDate = today;
                            }
                            else
                            {
                                nextValidDueDate = today.AddDays(1);
                            }
                            break;

                        case TaskRepetitionType.Weekly:
                            if (task.RepetitionDayOfWeek.HasValue)
                            {
                                // Find the next occurrence starting from today
                                nextValidDueDate = DateUtils.GetNextWeekday(today, task.RepetitionDayOfWeek.Value);
                            }
                            else
                            {
                                // Fallback if day is somehow missing (shouldn't happen with UI)
                                // Advance week by week until >= today
                                while (nextValidDueDate < today)
                                {
                                    nextValidDueDate = nextValidDueDate.AddDays(7);
                                }
                            }
                            break;
                    }

                    // Update if calculated date is different
                    if (task.DueDate.Value.Date != nextValidDueDate)
                    {
                        Debug.WriteLine($"LoadTasksAsync: Adjusting overdue task '{task.Title}' ({task.RepetitionType}) from {task.DueDate.Value.Date:d} to {nextValidDueDate:d}");
                        task.DueDate = nextValidDueDate;
                        changesMade = true; // Mark that a change occurred
                    }
                }
            }
            // --- End Adjustment Logic ---

            // Sort loaded tasks by original order before adding to collection
            var tasksToAdd = loadedTasks.OrderBy(t => t.Order).ToList();

            await MainThread.InvokeOnMainThreadAsync(() =>
            {
                Tasks.Clear();
                foreach (var task in tasksToAdd) { task.IsFadingOut = false; Tasks.Add(task); }
                UpdateTaskOrderProperty(); // Ensure order property is consistent
            });

            // Reset sort display to Manual after loading
            _currentSortOrder = SortOrderType.Manual;
            UpdateSelectedSortOptionDisplay(SortOrderType.Manual);

            // Save changes if any dates were adjusted during load
            if (changesMade)
            {
                Debug.WriteLine("LoadTasksAsync: Saving tasks due to date adjustments.");
                await TriggerSave(); // Use TriggerSave for debouncing/locking
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"LoadTasksAsync: Error loading tasks: {ex.GetType().Name} - {ex.Message}");
            if (Tasks.Any()) await MainThread.InvokeOnMainThreadAsync(Tasks.Clear);
            _currentSortOrder = SortOrderType.Manual;
            UpdateSelectedSortOptionDisplay(SortOrderType.Manual);
        }
        finally
        {
            // Re-subscribe ONLY if needed (if collection has items or was previously subscribed)
            if (wasSubscribed || Tasks.Any())
            {
                Tasks.CollectionChanged -= Tasks_CollectionChanged; // Ensure no double subscription
                Tasks.CollectionChanged += Tasks_CollectionChanged;
            }
        }
    }

    [RelayCommand]
    private async Task MarkTaskDone(TaskItem? task)
    {
        if (task == null || task.IsFadingOut) { return; }
        if (task.TimeType == TaskTimeType.None || task.TimeType == TaskTimeType.SpecificDate)
        {
            task.IsFadingOut = true;
            await Task.Delay(350);
            await MainThread.InvokeOnMainThreadAsync(async () => { if (Tasks.Remove(task)) { UpdateTaskOrderProperty(); await TriggerSave(); } else { task.IsFadingOut = false; } });
            ResetSortToManual();
        }
        else if (task.TimeType == TaskTimeType.Repeating)
        {
            // Calculate the NEXT due date based on the CURRENT due date
            DateTime? nextDueDate = DateUtils.CalculateNextDueDate(task);
            if (nextDueDate.HasValue)
            {
                // Temporarily store old task data if needed for smooth UI update
                // var oldTaskData = new { task.Title, task.Priority, task.TimeType, task.RepetitionType, task.RepetitionDayOfWeek, task.Order };

                // Update the due date *before* removing/adding to avoid flicker if possible
                task.DueDate = nextDueDate;

                // Instead of Remove/Add which can cause visual jump, try updating in place
                // Find the index and trigger property change notifications
                await MainThread.InvokeOnMainThreadAsync(async () =>
                {
                    int index = Tasks.IndexOf(task);
                    if (index != -1)
                    {
                        // No need to Remove/Add if just updating properties of the existing object
                        // The UI should update based on INotifyPropertyChanged from TaskItem.DueDate
                        // Force a refresh of the item binding if needed (less common now with ObservableObject)
                        // Tasks[index] = task; // Reassigning might trigger UI refresh more reliably for some collection views
                        UpdateTaskOrderProperty(); // Update order just in case
                        await TriggerSave(); // Save the updated task
                    }
                    else
                    {
                        // Fallback if task was somehow not found (unlikely)
                        if (Tasks.Remove(task)) // If removed successfully, add back the updated one
                        {
                            Tasks.Add(task); // Add updated task back (might go to end)
                            UpdateTaskOrderProperty(); // Re-apply order
                            await TriggerSave();
                        }
                    }
                });

                // Re-apply sort if needed (or reset to manual)
                if (_currentSortOrder != SortOrderType.Manual)
                {
                    ApplySortOrderCommand.Execute(null); // Re-apply current sort
                }
                else
                {
                    // If manual, we might want to keep it manual, or potentially
                    // move the task based on its new date if dates were visible in manual sort
                    // For now, just save and keep manual order
                }
            }
            else
            {
                // Handle cases where next due date couldn't be calculated (error or unexpected type)
                Debug.WriteLine($"MarkTaskDone: Could not calculate next due date for repeating task '{task.Title}'. Removing.");
                // Fallback to remove like non-repeating
                task.IsFadingOut = true;
                await Task.Delay(350);
                await MainThread.InvokeOnMainThreadAsync(async () => { if (Tasks.Remove(task)) { UpdateTaskOrderProperty(); await TriggerSave(); } else { task.IsFadingOut = false; } });
                ResetSortToManual();
            }
        }
    }

    [RelayCommand]
    private async Task ApplySortOrder()
    {
        SortOrderType requestedSortOrder = SelectedSortOption switch { "Priority (High First)" => SortOrderType.PriorityHighFirst, "Priority (Low First)" => SortOrderType.PriorityLowFirst, _ => SortOrderType.Manual };

        // If requesting manual sort, reload from saved order
        if (requestedSortOrder == SortOrderType.Manual && _currentSortOrder != SortOrderType.Manual)
        {
            await LoadTasksAsync(); // Reloads using saved 'Order' property
            return;
        }

        // Avoid re-sorting if already sorted that way
        if (requestedSortOrder == _currentSortOrder && requestedSortOrder != SortOrderType.Manual) { return; }


        List<TaskItem> currentTasks = new List<TaskItem>();
        await MainThread.InvokeOnMainThreadAsync(() => { currentTasks = new List<TaskItem>(Tasks); });

        List<TaskItem> sortedTasks;
        if (requestedSortOrder == SortOrderType.PriorityHighFirst) { sortedTasks = currentTasks.OrderBy(t => t.Priority).ThenBy(t => t.Title, StringComparer.OrdinalIgnoreCase).ToList(); }
        else if (requestedSortOrder == SortOrderType.PriorityLowFirst) { sortedTasks = currentTasks.OrderByDescending(t => t.Priority).ThenBy(t => t.Title, StringComparer.OrdinalIgnoreCase).ToList(); }
        else { return; } // Should be handled by reload case above


        // Avoid UI churn if the order hasn't actually changed
        if (currentTasks.SequenceEqual(sortedTasks))
        {
            _currentSortOrder = requestedSortOrder; // Update state even if sequence is same
            UpdateSelectedSortOptionDisplay(requestedSortOrder); // Reflect in Picker
            return;
        }


        Tasks.CollectionChanged -= Tasks_CollectionChanged; // Prevent triggering save on each add/remove
        try
        {
            await MainThread.InvokeOnMainThreadAsync(() =>
            {
                Tasks.Clear();
                foreach (var task in sortedTasks)
                {
                    Tasks.Add(task); // Add tasks in the new sorted order
                }
                // Note: Do NOT update Task.Order property here, as that reflects manual order
            });
            // Do NOT save here, sorting is temporary view state unless it's manual
            _currentSortOrder = requestedSortOrder;
            UpdateSelectedSortOptionDisplay(requestedSortOrder); // Ensure Picker reflects sort
        }
        catch (Exception ex) { Debug.WriteLine($"ApplySortOrder: Error during sorting: {ex.Message}"); }
        finally { if (Tasks.Any()) { Tasks.CollectionChanged -= Tasks_CollectionChanged; Tasks.CollectionChanged += Tasks_CollectionChanged; } } // Re-attach handler
    }

    private async void HandleCalendarSettingChanged()
    {
        // Reload tasks to reflect new calendar formatting
        await LoadTasksAsync();
    }
    private async void HandleAddTask(TaskItem? newTask)
    {
        if (newTask == null) return;
        await MainThread.InvokeOnMainThreadAsync(async () =>
        {
            newTask.Order = Tasks.Count; // Assign next available order index
            Tasks.Add(newTask);
            // UpdateTaskOrderProperty(); // Redundant as we just set it
            await TriggerSave(); // Save the new task and its order
        });
        // If currently sorted, adding might disrupt sort. Reset to manual or re-apply sort.
        // Resetting to manual is safest as new item position in sorted list isn't obvious
        ResetSortToManual();
    }
    private async void HandleUpdateTask(TaskItem? updatedTask)
    {
        if (updatedTask == null) return;
        await MainThread.InvokeOnMainThreadAsync(async () =>
        {
            int index = -1;
            for (int i = 0; i < Tasks.Count; i++)
            {
                if (Tasks[i].Id == updatedTask.Id)
                {
                    index = i;
                    break;
                }
            }
            if (index != -1)
            {
                // Preserve original order unless explicitly changed
                updatedTask.Order = Tasks[index].Order;
                Tasks[index] = updatedTask; // Replace item in collection
                await TriggerSave(); // Save the changes
            }
        });
        // If currently sorted, updating might change position. Reset to manual or re-apply sort.
        ResetSortToManual();
    }
    private async void HandleDeleteTask(Guid taskId)
    {
        await MainThread.InvokeOnMainThreadAsync(async () =>
        {
            var taskToRemove = Tasks.FirstOrDefault(t => t.Id == taskId);
            if (taskToRemove != null)
            {
                if (Tasks.Remove(taskToRemove))
                {
                    UpdateTaskOrderProperty(); // Re-assign order indexes to remaining tasks
                    await TriggerSave(); // Save the updated list and orders
                }
            }
        });
        // Deleting might affect sorted view, but usually safe to keep current sort
        // Resetting to manual ensures consistency if needed.
        // ResetSortToManual(); // Optional: uncomment if deleting should always reset sort
    }
    private async void Tasks_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        // Only save when items are manually reordered (Move action)
        if (e.Action == NotifyCollectionChangedAction.Move)
        {
            await MainThread.InvokeOnMainThreadAsync(async () =>
            {
                UpdateTaskOrderProperty(); // Update Order property based on new positions
                await TriggerSave(); // Save the new manual order
            });
            // User manually reordered, so switch back to Manual sort view
            ResetSortToManual();
        }
        // Add/Remove/Replace actions trigger saves within their respective handlers (HandleAddTask, etc.)
        // Reset action is handled by LoadTasksAsync
    }
    private void UpdateTaskOrderProperty()
    {
        if (!MainThread.IsMainThread) { MainThread.BeginInvokeOnMainThread(UpdateTaskOrderPropertyInternal); }
        else { UpdateTaskOrderPropertyInternal(); }
    }
    private void UpdateTaskOrderPropertyInternal()
    {
        for (int i = 0; i < Tasks.Count; i++)
        {
            // Check bounds and null before accessing Task properties
            if (i < Tasks.Count && Tasks[i] != null && Tasks[i].Order != i)
            {
                Tasks[i].Order = i; // Assign index as the Order value for saving manual order
            }
        }
    }
    private async Task SaveTasks()
    {
        bool acquiredLock = false;
        List<TaskItem> tasksToSave = new List<TaskItem>();

        try
        {
            // Ensure thread safety for checking/setting _isSaving flag
            lock (_saveLock)
            {
                if (_isSaving)
                {
                    Debug.WriteLine("SaveTasks: Save already in progress. Skipping.");
                    return; // Exit if another save is running
                }
                _isSaving = true; // Mark as saving
                acquiredLock = true;
            }

            // Prepare the list of tasks to save on the main thread to ensure collection consistency
            await MainThread.InvokeOnMainThreadAsync(() =>
            {
                UpdateTaskOrderPropertyInternal(); // Ensure orders are correct before saving
                tasksToSave = new List<TaskItem>(Tasks); // Create a copy for serialization
            });

            if (tasksToSave != null) // Check if list creation succeeded
            {
                // Sort by the Order property before serializing to preserve manual order
                tasksToSave = tasksToSave.OrderBy(t => t.Order).ToList();

                string json = JsonSerializer.Serialize(tasksToSave, new JsonSerializerOptions { WriteIndented = true });
                await File.WriteAllTextAsync(_filePath, json);
                Debug.WriteLine($"SaveTasks: Successfully saved {tasksToSave.Count} tasks to {_filePath}");
            }
        }
        catch (Exception ex) { Debug.WriteLine($"SaveTasks: Error saving tasks: {ex.Message}"); }
        finally
        {
            if (acquiredLock)
            {
                // Release the saving flag
                lock (_saveLock) { _isSaving = false; }
            }
        }
    }
    // Debounced save trigger
    private System.Threading.Timer? _debounceTimer;
    private async Task TriggerSave()
    {
        // Dispose previous timer if exists
        _debounceTimer?.Dispose();

        // Create a new timer that calls SaveTasks after a delay
        _debounceTimer = new System.Threading.Timer(async (_) =>
        {
            await SaveTasks(); // Call the actual save method
            _debounceTimer?.Dispose(); // Clean up the timer after execution
            _debounceTimer = null;
        },
        null, // No state needed
        TimeSpan.FromMilliseconds(500), // Wait 500ms before saving
        Timeout.InfiniteTimeSpan); // Don't repeat automatically
    }
    private void ResetSortToManual()
    {
        if (_currentSortOrder != SortOrderType.Manual)
        {
            _currentSortOrder = SortOrderType.Manual;
            UpdateSelectedSortOptionDisplay(SortOrderType.Manual);
            // Optionally, explicitly reload to guarantee view matches saved order
            // _ = LoadTasksAsync(); // Uncomment if needed, but might be overkill
        }
    }
    private void UpdateSelectedSortOptionDisplay(SortOrderType sortOrder)
    {
        string newDisplayValue = sortOrder switch
        {
            SortOrderType.PriorityHighFirst => SortOptionsDisplay[1],
            SortOrderType.PriorityLowFirst => SortOptionsDisplay[2],
            _ => SortOptionsDisplay[0]
        };
        if (_selectedSortOption != newDisplayValue)
        {
            // Use SetProperty to ensure UI update via INotifyPropertyChanged
            SetProperty(ref _selectedSortOption, newDisplayValue, nameof(SelectedSortOption));
            Debug.WriteLine($"UpdateSelectedSortOptionDisplay: Picker set to '{newDisplayValue}'");
        }
    }

    private async Task HandleTasksReloadRequested()
    {
        Debug.WriteLine("MainViewModel: Received TasksReloadRequestedMessage. Reloading tasks...");
        await LoadTasksAsync();
    }
}

--------------------------------------------------------------------------------

// * File: ViewModels\SettingsViewModel.cs---
// File: ViewModels/SettingsViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input; // Needed for RelayCommand
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Maui.Storage;
using System.ComponentModel;
using System.Diagnostics;
using Tickly.Messages;
using Tickly.Models;
using Tickly.Services;
using System.Collections.Generic; // For EqualityComparer
using System.IO; // For Path, File
using System.Text.Json; // For JsonSerializer validation
using System.Threading.Tasks; // For Task
using Microsoft.Maui.ApplicationModel; // For Permissions, Share, FilePicker

namespace Tickly.ViewModels
{
    public partial class SettingsViewModel : ObservableObject
    {
        [ObservableProperty]
        private bool _isGregorianSelected;

        [ObservableProperty]
        private bool _isPersianSelected;

        // Path to the app's internal tasks file
        private readonly string _appTasksFilePath;

        public SettingsViewModel()
        {
            _appTasksFilePath = Path.Combine(FileSystem.AppDataDirectory, "tasks.json");

            LoadSettings();
            this.PropertyChanged += SettingsViewModel_PropertyChanged;
        }


        private void LoadSettings()
        {
            var currentSystem = AppSettings.SelectedCalendarSystem;
            Debug.WriteLine($"SettingsViewModel: Loading initial state from AppSettings. CurrentSystem='{currentSystem}'");
            UpdateProperty(ref _isGregorianSelected, currentSystem == CalendarSystemType.Gregorian, nameof(IsGregorianSelected));
            UpdateProperty(ref _isPersianSelected, currentSystem == CalendarSystemType.Persian, nameof(IsPersianSelected));
        }

        private void SettingsViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            CalendarSystemType newSystem;

            if (e.PropertyName == nameof(IsGregorianSelected) && IsGregorianSelected)
            {
                newSystem = CalendarSystemType.Gregorian;
                if (IsPersianSelected) UpdateProperty(ref _isPersianSelected, false, nameof(IsPersianSelected));
            }
            else if (e.PropertyName == nameof(IsPersianSelected) && IsPersianSelected)
            {
                newSystem = CalendarSystemType.Persian;
                if (IsGregorianSelected) UpdateProperty(ref _isGregorianSelected, false, nameof(IsGregorianSelected));
            }
            else { return; } // Only handle changes to these specific boolean properties

            // Check if the AppSetting actually needs changing
            if (AppSettings.SelectedCalendarSystem != newSystem)
            {
                Debug.WriteLine($"SettingsViewModel: PropertyChanged detected user change to {newSystem}. Saving and notifying.");
                AppSettings.SelectedCalendarSystem = newSystem;
                Preferences.Set(AppSettings.CalendarSystemKey, (int)newSystem);
                WeakReferenceMessenger.Default.Send(new CalendarSettingChangedMessage());
                Debug.WriteLine("SettingsViewModel: Sent CalendarSettingChangedMessage.");
            }
        }

        // *** NEW Export Command ***
        [RelayCommand]
        private async Task ExportTasksAsync()
        {
            Debug.WriteLine("ExportTasksAsync: Initiating export...");
            try
            {
                if (!File.Exists(_appTasksFilePath))
                {
                    Debug.WriteLine("ExportTasksAsync: No tasks file found to export.");
                    await ShowAlert("Export Failed", "No tasks file exists to export.", "OK");
                    return;
                }

                // Use MAUI Share API to let user choose destination
                await Share.RequestAsync(new ShareFileRequest
                {
                    Title = "Export Tickly Tasks",
                    File = new ShareFile(_appTasksFilePath, "application/json") // Specify MIME type
                });

                Debug.WriteLine("ExportTasksAsync: Share request completed (user may have saved or cancelled).");
                // Optionally show a confirmation, but Share doesn't give explicit success feedback
                // await ShowAlert("Export", "Share/Save dialog opened.", "OK");

            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ExportTasksAsync: Error during export: {ex.Message}");
                await ShowAlert("Export Error", $"An error occurred during export: {ex.Message}", "OK");
            }
        }
        // *** END Export Command ***

        // *** NEW Import Command ***
        [RelayCommand]
        private async Task ImportTasksAsync()
        {
            Debug.WriteLine("ImportTasksAsync: Initiating import...");
            try
            {
                var customFileType = new FilePickerFileType(
                    new Dictionary<DevicePlatform, IEnumerable<string>>
                    {
                        { DevicePlatform.iOS, new[] { "public.json" } }, // UTType
                        { DevicePlatform.Android, new[] { "application/json" } }, // MIME type
                        { DevicePlatform.WinUI, new[] { ".json" } }, // file extension
                        { DevicePlatform.MacCatalyst, new[] { "json" } }, // UTType
                    });

                var options = new PickOptions
                {
                    PickerTitle = "Select Tickly tasks JSON file",
                    FileTypes = customFileType,
                };

                var result = await FilePicker.PickAsync(options);
                if (result == null)
                {
                    Debug.WriteLine("ImportTasksAsync: File picking cancelled by user.");
                    return;
                }

                Debug.WriteLine($"ImportTasksAsync: File picked: {result.FullPath}");

                // --- Basic Validation ---
                string fileContent;
                try
                {
                    fileContent = await File.ReadAllTextAsync(result.FullPath);
                    // Attempt deserialization just to see if it's plausible JSON structure
                    _ = JsonSerializer.Deserialize<List<TaskItem>>(fileContent);
                    Debug.WriteLine("ImportTasksAsync: File content successfully deserialized (basic validation passed).");
                }
                catch (JsonException jsonEx)
                {
                    Debug.WriteLine($"ImportTasksAsync: Invalid JSON format: {jsonEx.Message}");
                    await ShowAlert("Import Failed", "The selected file is not a valid JSON task file.", "OK");
                    return;
                }
                catch (Exception readEx)
                {
                    Debug.WriteLine($"ImportTasksAsync: Error reading selected file: {readEx.Message}");
                    await ShowAlert("Import Failed", $"Could not read the selected file: {readEx.Message}", "OK");
                    return;
                }

                // --- Confirmation ---
                bool confirmed = await ShowConfirmation("Confirm Import", "This will REPLACE your current tasks with the content of the selected file. This cannot be undone. Proceed?", "Replace", "Cancel");

                if (!confirmed)
                {
                    Debug.WriteLine("ImportTasksAsync: Import cancelled by user confirmation.");
                    return;
                }

                // --- Replace File ---
                try
                {
                    File.Copy(result.FullPath, _appTasksFilePath, true); // Overwrite existing file
                    Debug.WriteLine($"ImportTasksAsync: Successfully copied selected file to {_appTasksFilePath}");

                    // --- Trigger Reload ---
                    WeakReferenceMessenger.Default.Send(new TasksReloadRequestedMessage());
                    Debug.WriteLine("ImportTasksAsync: Sent TasksReloadRequestedMessage.");

                    await ShowAlert("Import Successful", "Tasks imported successfully. The task list has been updated.", "OK");
                }
                catch (Exception copyEx)
                {
                    Debug.WriteLine($"ImportTasksAsync: Error copying file: {copyEx.Message}");
                    await ShowAlert("Import Failed", $"Could not replace the tasks file: {copyEx.Message}", "OK");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ImportTasksAsync: General error during import: {ex.Message}");
                await ShowAlert("Import Error", $"An unexpected error occurred during import: {ex.Message}", "OK");
            }
        }
        // *** END Import Command ***


        // Helper for showing alerts (slight MVVM violation for simplicity)
        private async Task ShowAlert(string title, string message, string cancel)
        {
            if (Application.Current?.MainPage != null)
            {
                await Application.Current.MainPage.DisplayAlert(title, message, cancel);
            }
        }

        // Helper for showing confirmation dialog
        private async Task<bool> ShowConfirmation(string title, string message, string accept, string cancel)
        {
            if (Application.Current?.MainPage != null)
            {
                return await Application.Current.MainPage.DisplayAlert(title, message, accept, cancel);
            }
            return false; // Cannot show dialog
        }


        protected bool UpdateProperty<T>(ref T field, T value, string propertyName)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}

--------------------------------------------------------------------------------

// * File: Views\AddTaskPopupPage.xaml---
<?xml version="1.0" encoding="utf-8" ?>
<!-- Views/AddTaskPopupPage.xaml -->
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:models="clr-namespace:Tickly.Models"
             xmlns:converters="clr-namespace:Tickly.Converters"
             xmlns:vm="clr-namespace:Tickly.Views"
             x:Class="Tickly.Views.AddTaskPopupPage"
             x:DataType="vm:AddTaskPopupPageViewModel"
             BackgroundColor="Black"
             Title="{Binding PageTitle}">
    <!-- Dynamic Page Title (Add New Task / Edit Task) -->
    <!-- Set DataType for compile-time checking and intellisense -->

    <ContentPage.Resources>
        <ResourceDictionary>
            <converters:InverseBooleanConverter x:Key="InverseBooleanConverter" />
            <!-- Styles -->
            <Style TargetType="Entry" x:Key="MinimalEntry">
                <Setter Property="TextColor" Value="White" />
                <Setter Property="PlaceholderColor" Value="Gray" />
                <Setter Property="BackgroundColor" Value="Transparent" />
                <Setter Property="Margin" Value="0,0,0,5" />
            </Style>
            <!-- Ensure Primary color is defined globally -->
            <!-- <Color x:Key="Primary">#512BD4</Color> -->
        </ResourceDictionary>
    </ContentPage.Resources>

    <ScrollView>
        <VerticalStackLayout Padding="20" Spacing="15">

            <!-- Task Title Input -->
            <Label Text="Task Title" TextColor="WhiteSmoke"/>
            <Entry x:Name="TitleEntry"
                   Placeholder="Enter task title"
                   Text="{Binding Title}"
                   Style="{StaticResource MinimalEntry}" />

            <!-- Priority Selection -->
            <Label Text="Priority" TextColor="WhiteSmoke"/>
            <HorizontalStackLayout Spacing="10" BindableLayout.ItemsSource="{Binding PriorityOptions}">
                <BindableLayout.ItemTemplate>
                    <DataTemplate x:DataType="vm:SelectableOption(models:TaskPriority)">
                        <RadioButton GroupName="PriorityGroup"
                                     IsChecked="{Binding IsSelected}"
                                     Content="{Binding Name}"
                                     TextColor="WhiteSmoke" />
                    </DataTemplate>
                </BindableLayout.ItemTemplate>
            </HorizontalStackLayout>

            <!-- Time / Repetition Type Selection -->
            <Label Text="Time / Repetition" TextColor="WhiteSmoke"/>
            <VerticalStackLayout Spacing="5">
                <RadioButton GroupName="TimeTypeGroup" Content="None (Any time)" TextColor="WhiteSmoke"
                             IsChecked="{Binding IsTimeTypeNone}" />
                <RadioButton GroupName="TimeTypeGroup" Content="Specific Date" TextColor="WhiteSmoke"
                             IsChecked="{Binding IsTimeTypeSpecificDate}" />
                <RadioButton GroupName="TimeTypeGroup" Content="Repeating" TextColor="WhiteSmoke"
                              IsChecked="{Binding IsTimeTypeRepeating}" />
            </VerticalStackLayout>

            <!-- Specific Date Picker (Visible only when SpecificDate is selected) -->
            <DatePicker x:Name="DueDatePicker"
                        Date="{Binding DueDate}"
                        TextColor="WhiteSmoke"
                        BackgroundColor="#1E1E1E"
                        IsVisible="{Binding IsTimeTypeSpecificDate}"
                        Margin="20,0,0,0" />

            <!-- Repetition Options Section (Visible only when Repeating is selected) -->
            <VerticalStackLayout Spacing="10" Margin="20,5,0,0"
                                 IsVisible="{Binding IsTimeTypeRepeating}">

                <Label Text="Repeat:" TextColor="LightGray"/>
                <HorizontalStackLayout Spacing="10" BindableLayout.ItemsSource="{Binding RepetitionTypeOptions}">
                    <BindableLayout.ItemTemplate>
                        <DataTemplate x:DataType="vm:SelectableOption(models:TaskRepetitionType)">
                            <RadioButton GroupName="RepetitionTypeGroup"
                                         IsChecked="{Binding IsSelected}"
                                         Content="{Binding Name}"
                                         TextColor="WhiteSmoke" />
                        </DataTemplate>
                    </BindableLayout.ItemTemplate>
                </HorizontalStackLayout>

                <!-- *** Start Date for Repetition Picker REMOVED *** -->
                <!-- <StackLayout Orientation="Horizontal" Spacing="5" Margin="0,5,0,0"> -->
                <!--     <Label Text="Starting:" VerticalOptions="Center" TextColor="LightGray"/> -->
                <!--     <DatePicker x:Name="RepeatStartDatePicker" -->
                <!--                 Date="{Binding DueDate}" -->
                <!--                 TextColor="WhiteSmoke" -->
                <!--                 BackgroundColor="#1E1E1E" /> -->
                <!-- </StackLayout> -->

                <!-- Day of Week Picker (Visible only for Weekly repetition) -->
                <StackLayout Orientation="Horizontal" Spacing="5" Margin="0,5,0,0"
                             IsVisible="{Binding IsWeeklySelected}">
                    <Label Text="On:" VerticalOptions="Center" TextColor="LightGray"/>
                    <Picker x:Name="DayOfWeekPicker"
                            Title="Select Day"
                            TextColor="WhiteSmoke"
                            BackgroundColor="#1E1E1E"
                            ItemsSource="{Binding DisplayDaysOfWeek}"
                            SelectedItem="{Binding SelectedDisplayDayOfWeek}"
                            WidthRequest="150" />
                </StackLayout>
            </VerticalStackLayout>

            <!-- Action Buttons -->
            <Grid ColumnDefinitions="Auto,*,Auto,Auto" ColumnSpacing="10" Margin="0,20,0,0">
                <Button Grid.Column="0" Text="Delete" Clicked="OnDeleteClicked" BackgroundColor="DarkRed" TextColor="White" IsVisible="{Binding IsEditMode}" HorizontalOptions="Start" />
                <Button Grid.Column="2" Text="Cancel" Clicked="OnCancelClicked" BackgroundColor="#444444" TextColor="WhiteSmoke" HorizontalOptions="End" />
                <Button Grid.Column="3" Text="{Binding ConfirmButtonText}" Clicked="OnConfirmClicked" BackgroundColor="{StaticResource Primary}" TextColor="Black" HorizontalOptions="End" />
            </Grid>

        </VerticalStackLayout>
    </ScrollView>
</ContentPage>

--------------------------------------------------------------------------------

// * File: Views\AddTaskPopupPage.xaml.cs---
// File: Views\AddTaskPopupPage.xaml.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Microsoft.Maui.Controls;
using Tickly.Messages; // Ensure UpdateTaskMessage and DeleteTaskMessage are included
using Tickly.Models;
using System.Diagnostics; // For Debug.WriteLine

namespace Tickly.Views
{
    // Helper class for binding collections to RadioButtons
    public partial class SelectableOption<T> : ObservableObject
    {
        [ObservableProperty]
        private bool _isSelected;
        public string Name { get; }
        public T Value { get; }

        public SelectableOption(string name, T value, bool isSelected = false)
        {
            Name = name;
            Value = value;
            IsSelected = isSelected;
        }
    }

    // ViewModel for the Add/Edit Task Page
    public partial class AddTaskPopupPageViewModel : ObservableObject
    {
        // Properties bound to UI controls
        [ObservableProperty] private string _title = string.Empty; // Add Title property for binding
        [ObservableProperty] private DateTime _dueDate = DateTime.Today;
        [ObservableProperty] private bool _isTimeTypeNone = true; // Default selection
        [ObservableProperty] private bool _isTimeTypeSpecificDate;
        [ObservableProperty] private bool _isTimeTypeRepeating;
        [ObservableProperty] private ObservableCollection<SelectableOption<TaskPriority>> _priorityOptions;
        [ObservableProperty] private ObservableCollection<SelectableOption<TaskRepetitionType>> _repetitionTypeOptions;
        [ObservableProperty] private bool _isWeeklySelected; // Controls visibility of DayOfWeek picker

        // Updated: Use List<string> for display names to simplify binding
        [ObservableProperty] private List<string> _displayDaysOfWeek;
        [ObservableProperty] private string _selectedDisplayDayOfWeek;

        // Internal property to track the original TaskItem for Edit mode
        private TaskItem? _originalTask;

        // Properties for UI state (EditMode, Titles)
        [ObservableProperty] private bool _isEditMode;
        [ObservableProperty] private string _pageTitle = "Add New Task";
        [ObservableProperty] private string _confirmButtonText = "Add Task";

        public AddTaskPopupPageViewModel()
        {
            // Initialize Priority options (without color names)
            PriorityOptions = new ObservableCollection<SelectableOption<TaskPriority>>
            {
                new SelectableOption<TaskPriority>("High", TaskPriority.High),
                new SelectableOption<TaskPriority>("Medium", TaskPriority.Medium, true), // Default selected
                new SelectableOption<TaskPriority>("Low", TaskPriority.Low)
            };

            // Initialize Repetition options
            RepetitionTypeOptions = new ObservableCollection<SelectableOption<TaskRepetitionType>>
            {
                new SelectableOption<TaskRepetitionType>("Daily", TaskRepetitionType.Daily, true), // Default selected
                new SelectableOption<TaskRepetitionType>("Alternate Day", TaskRepetitionType.AlternateDay),
                new SelectableOption<TaskRepetitionType>("Weekly", TaskRepetitionType.Weekly)
            };

            // Initialize Display Days of Week
            // Use CultureInfo.InvariantCulture to ensure consistent order regardless of system settings
            var culture = System.Globalization.CultureInfo.InvariantCulture;
            DisplayDaysOfWeek = culture.DateTimeFormat.DayNames.ToList();
            // Set default selected display day based on Today
            SelectedDisplayDayOfWeek = culture.DateTimeFormat.GetDayName(DateTime.Today.DayOfWeek);

            // Handle changes in RepetitionType selection to show/hide DayOfWeek picker
            foreach (var option in RepetitionTypeOptions)
            {
                option.PropertyChanged += (sender, args) =>
                {
                    if (args.PropertyName == nameof(SelectableOption<TaskRepetitionType>.IsSelected))
                    {
                        var changedOption = sender as SelectableOption<TaskRepetitionType>;
                        // If this option became selected, update IsWeeklySelected based on its value
                        if (changedOption != null && changedOption.IsSelected)
                        {
                            IsWeeklySelected = (changedOption.Value == TaskRepetitionType.Weekly);
                        }
                        // Handle case where Weekly might be deselected (though RadioButton group should prevent direct deselection)
                        // Check if the currently selected option *is not* Weekly
                        else if (changedOption != null && !changedOption.IsSelected && changedOption.Value == TaskRepetitionType.Weekly)
                        {
                            if (RepetitionTypeOptions.FirstOrDefault(o => o.IsSelected)?.Value != TaskRepetitionType.Weekly)
                            {
                                IsWeeklySelected = false;
                            }
                        }
                    }
                };
            }
            // Initial check for DayOfWeek picker visibility
            IsWeeklySelected = RepetitionTypeOptions.FirstOrDefault(o => o.IsSelected)?.Value == TaskRepetitionType.Weekly;

            // Handle changes in the main TimeType selection (None, Specific, Repeating)
            this.PropertyChanged += (sender, args) =>
            {
                if (args.PropertyName == nameof(IsTimeTypeRepeating) || args.PropertyName == nameof(IsTimeTypeSpecificDate) || args.PropertyName == nameof(IsTimeTypeNone))
                {
                    // Ensure DayOfWeek picker visibility is correct based on whether Repeating is selected AND Weekly is chosen
                    IsWeeklySelected = IsTimeTypeRepeating && (RepetitionTypeOptions.FirstOrDefault(o => o.IsSelected)?.Value == TaskRepetitionType.Weekly);
                }
            };
        }

        // Populates the ViewModel fields based on an existing TaskItem (for editing)
        public void LoadFromTask(TaskItem task)
        {
            _originalTask = task; // Store the original task
            IsEditMode = true; // Set EditMode flag
            PageTitle = "Edit Task";
            ConfirmButtonText = "Update Task";

            Title = task.Title; // Load title into ViewModel property

            // Set Priority RadioButton
            foreach (var option in PriorityOptions)
                option.IsSelected = (option.Value == task.Priority);
            if (!PriorityOptions.Any(o => o.IsSelected)) // Ensure default if no match
                PriorityOptions.FirstOrDefault(o => o.Value == TaskPriority.Medium)!.IsSelected = true;

            // Set TimeType RadioButtons
            IsTimeTypeNone = task.TimeType == TaskTimeType.None;
            IsTimeTypeSpecificDate = task.TimeType == TaskTimeType.SpecificDate;
            IsTimeTypeRepeating = task.TimeType == TaskTimeType.Repeating;

            // Set DatePicker value (used for Specific Date or Repeating Start Date)
            DueDate = task.DueDate ?? DateTime.Today; // Use today if null

            // Set Repetition details if applicable
            if (task.TimeType == TaskTimeType.Repeating)
            {
                // Set Repetition Type RadioButton
                foreach (var option in RepetitionTypeOptions)
                    option.IsSelected = (option.Value == task.RepetitionType);
                if (!RepetitionTypeOptions.Any(o => o.IsSelected)) // Ensure default if no match
                    RepetitionTypeOptions.FirstOrDefault(o => o.Value == TaskRepetitionType.Daily)!.IsSelected = true;

                // Set DayOfWeek Picker selected item using display name
                var culture = System.Globalization.CultureInfo.InvariantCulture;
                SelectedDisplayDayOfWeek = culture.DateTimeFormat.GetDayName(task.RepetitionDayOfWeek ?? DateTime.Today.DayOfWeek);

                // Update DayOfWeek picker visibility based on loaded type
                IsWeeklySelected = RepetitionTypeOptions.FirstOrDefault(o => o.IsSelected)?.Value == TaskRepetitionType.Weekly;
            }
            else
            {
                // Reset repetition details if not a repeating task
                RepetitionTypeOptions.FirstOrDefault(o => o.Value == TaskRepetitionType.Daily)!.IsSelected = true;
                var culture = System.Globalization.CultureInfo.InvariantCulture;
                SelectedDisplayDayOfWeek = culture.DateTimeFormat.GetDayName(DateTime.Today.DayOfWeek);
                IsWeeklySelected = false;
            }
        }

        // Method to create or update a TaskItem based on ViewModel state
        public TaskItem? GetTaskItem()
        {
            // --- 1. Validate Input ---
            string title = Title?.Trim();
            if (string.IsNullOrWhiteSpace(title))
            {
                // Consider how to report validation errors (e.g., return null, throw exception)
                Debug.WriteLine("Validation Error: Task title cannot be empty.");
                return null;
            }

            // --- 2. Read Data from ViewModel ---
            // Priority
            var selectedPriorityOption = PriorityOptions.FirstOrDefault(p => p.IsSelected);
            TaskPriority priority = selectedPriorityOption?.Value ?? TaskPriority.Medium;

            // Time Type
            TaskTimeType timeType = IsTimeTypeSpecificDate ? TaskTimeType.SpecificDate :
                                    IsTimeTypeRepeating ? TaskTimeType.Repeating :
                                    TaskTimeType.None;

            // Due Date
            DateTime? dueDate = null;
            if (timeType == TaskTimeType.SpecificDate || timeType == TaskTimeType.Repeating)
            {
                dueDate = DueDate;
            }

            // Repetition Details
            TaskRepetitionType? repetitionType = null;
            DayOfWeek? repetitionDayOfWeek = null;
            if (timeType == TaskTimeType.Repeating)
            {
                var selectedRepetitionOption = RepetitionTypeOptions.FirstOrDefault(r => r.IsSelected);
                repetitionType = selectedRepetitionOption?.Value ?? TaskRepetitionType.Daily;

                if (repetitionType == TaskRepetitionType.Weekly)
                {
                    // Convert selected display name back to DayOfWeek enum
                    repetitionDayOfWeek = GetDayOfWeekFromDisplayName(SelectedDisplayDayOfWeek);
                }
            }

            // --- 3. Create or Update TaskItem ---
            if (IsEditMode && _originalTask != null) // Updating existing task
            {
                var updatedTask = new TaskItem(
                    title, priority, timeType, dueDate, repetitionType, repetitionDayOfWeek, _originalTask.Order // Keep original order
                )
                {
                    Id = _originalTask.Id // *** CRUCIAL: Assign the original ID ***
                };
                return updatedTask;
            }
            else // Adding new task
            {
                var newTask = new TaskItem(title, priority, timeType, dueDate, repetitionType, repetitionDayOfWeek);
                // Order will be assigned by MainViewModel
                return newTask;
            }
        }

        // Helper to convert display day name back to DayOfWeek enum
        private DayOfWeek? GetDayOfWeekFromDisplayName(string displayName)
        {
            var culture = System.Globalization.CultureInfo.InvariantCulture;
            for (int i = 0; i < culture.DateTimeFormat.DayNames.Length; i++)
            {
                if (culture.DateTimeFormat.DayNames[i].Equals(displayName, StringComparison.OrdinalIgnoreCase))
                {
                    return (DayOfWeek)i;
                }
            }
            return null; // Not found
        }

        // Optional: Reset state if needed when closing or cancelling
        public void Reset()
        {
            Title = string.Empty;
            PriorityOptions.FirstOrDefault(o => o.Value == TaskPriority.Medium)!.IsSelected = true; // Reset priority
            IsTimeTypeNone = true; // Reset TimeType
            IsTimeTypeSpecificDate = false;
            IsTimeTypeRepeating = false;
            DueDate = DateTime.Today;
            RepetitionTypeOptions.FirstOrDefault(o => o.Value == TaskRepetitionType.Daily)!.IsSelected = true; // Reset repetition type
            var culture = System.Globalization.CultureInfo.InvariantCulture;
            SelectedDisplayDayOfWeek = culture.DateTimeFormat.GetDayName(DateTime.Today.DayOfWeek); // Reset day
            IsWeeklySelected = false;

            _originalTask = null;
            IsEditMode = false;
            PageTitle = "Add New Task";
            ConfirmButtonText = "Add Task";

            // Important: Notify UI about all property changes after reset
            OnPropertyChanged(nameof(Title));
            OnPropertyChanged(nameof(IsTimeTypeNone));
            OnPropertyChanged(nameof(IsTimeTypeSpecificDate));
            OnPropertyChanged(nameof(IsTimeTypeRepeating));
            OnPropertyChanged(nameof(DueDate));
            OnPropertyChanged(nameof(SelectedDisplayDayOfWeek));
            OnPropertyChanged(nameof(IsWeeklySelected));
            OnPropertyChanged(nameof(IsEditMode));
            OnPropertyChanged(nameof(PageTitle));
            OnPropertyChanged(nameof(ConfirmButtonText));
            // Notify about collection changes if necessary (usually not needed for reset)
        }
    }

    // Code-behind for the Add/Edit Task Page
    [QueryProperty(nameof(TaskToEdit), "TaskToEdit")]
    public partial class AddTaskPopupPage : ContentPage
    {
        private AddTaskPopupPageViewModel _viewModel;
        // Remove _editingTask from code-behind, let ViewModel manage it
        // private TaskItem? _editingTask = null;

        // This property receives the TaskItem object during navigation for editing
        public TaskItem TaskToEdit
        {
            set
            {
                if (value != null) // If a TaskItem was passed
                {
                    Debug.WriteLine($"AddTaskPopupPage: Received TaskToEdit with ID: {value.Id}");
                    _viewModel.LoadFromTask(value); // Populate the ViewModel
                }
                else // Navigated without a TaskItem (e.g., adding new, or error)
                {
                    Debug.WriteLine("AddTaskPopupPage: Navigated without TaskToEdit (Add Mode).");
                    _viewModel.Reset(); // Reset ViewModel for adding
                }
            }
        }

        // Constructor
        public AddTaskPopupPage()
        {
            InitializeComponent(); // Standard MAUI XAML initialization
            _viewModel = new AddTaskPopupPageViewModel(); // Create the associated ViewModel
            BindingContext = _viewModel; // Set the page's BindingContext to the ViewModel
            // Initial state is handled by ViewModel constructor and Reset/LoadFromTask
        }

        // Remove PopulateFieldsFromTask - ViewModel handles loading now
        // private void PopulateFieldsFromTask(TaskItem task) { ... }

        // Handles the "Confirm" button click
        private async void OnConfirmClicked(object sender, EventArgs e)
        {
            var taskItem = _viewModel.GetTaskItem(); // Get the prepared TaskItem from ViewModel

            if (taskItem == null)
            {
                // Validation failed in ViewModel, show alert
                await DisplayAlert("Validation Error", "Task title cannot be empty.", "OK");
                return;
            }

            if (_viewModel.IsEditMode) // Check ViewModel's mode
            {
                Debug.WriteLine($"Sending UpdateTaskMessage for Task ID: {taskItem.Id}");
                WeakReferenceMessenger.Default.Send(new UpdateTaskMessage(taskItem));
            }
            else
            {
                Debug.WriteLine($"Sending AddTaskMessage for new task: {taskItem.Title}");
                WeakReferenceMessenger.Default.Send(new AddTaskMessage(taskItem));
            }

            // Close the Popup Page
            await Shell.Current.Navigation.PopModalAsync();
        }

        // Handles the "Cancel" button click
        private async void OnCancelClicked(object sender, EventArgs e)
        {
            // Simply close the popup page without saving/sending messages
            await Shell.Current.Navigation.PopModalAsync();
        }

        // *** ADDED METHOD ***
        // Handles the "Delete" button click (only visible in Edit mode)
        private async void OnDeleteClicked(object sender, EventArgs e)
        {
            // Get the task ID from the ViewModel (which holds the _originalTask)
            var taskToDelete = _viewModel.GetTaskItem(); // GetTaskItem returns the *updated* item but with original ID if editing

            if (_viewModel.IsEditMode && taskToDelete != null)
            {
                // Optional but recommended: Ask for confirmation before deleting
                bool confirmed = await DisplayAlert("Confirm Delete", $"Are you sure you want to delete the task '{taskToDelete.Title}'?", "Yes", "No");
                if (!confirmed)
                {
                    return; // User cancelled the deletion
                }

                Debug.WriteLine($"Sending DeleteTaskMessage for Task ID: {taskToDelete.Id}");
                // Send a message to the MainViewModel to delete this task using its ID
                WeakReferenceMessenger.Default.Send(new DeleteTaskMessage(taskToDelete.Id));

                // Close the Popup Page after sending the message
                await Shell.Current.Navigation.PopModalAsync();
            }
            else
            {
                // This case should ideally not happen because the button's visibility
                // is tied to IsEditMode (which implies _originalTask is not null in VM).
                Debug.WriteLine("OnDeleteClicked triggered but not in Edit Mode or Task ID missing. Cannot delete.");
                await DisplayAlert("Error", "Cannot delete task. No task loaded for editing.", "OK");
            }
        }
        // *** END OF ADDED METHOD ***


        // Optional: Called when navigating away from the page
        protected override void OnNavigatedFrom(NavigatedFromEventArgs args)
        {
            base.OnNavigatedFrom(args);
            // Reset the ViewModel when navigating away, so it's clean for the next time
            // unless navigation is due to Confirm/Delete (handled by PopModalAsync)
            // It might be safer to reset only on 'Cancel' or back navigation if needed.
            // For simplicity, we rely on the QueryProperty setter to manage state on next navigation.
            // _viewModel.Reset(); // Uncomment cautiously if needed
            Debug.WriteLine("AddTaskPopupPage: Navigated From.");
        }

        protected override void OnNavigatedTo(NavigatedToEventArgs args)
        {
            base.OnNavigatedTo(args);
            // The QueryProperty setter (TaskToEdit) handles setup based on navigation parameters.
            Debug.WriteLine($"AddTaskPopupPage: Navigated To. Edit Mode: {_viewModel.IsEditMode}");
        }

    } // End of AddTaskPopupPage class
} // End of namespace

--------------------------------------------------------------------------------

// * File: Views\SettingsPage.xaml---
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:vm="clr-namespace:Tickly.ViewModels"
             x:Class="Tickly.Views.SettingsPage"
             Title="Settings"
             BackgroundColor="Black">

    <ContentPage.BindingContext>
        <vm:SettingsViewModel />
    </ContentPage.BindingContext>

    <ScrollView>
        <VerticalStackLayout Padding="20" Spacing="15">

            <Label Text="Calendar Settings"
                   TextColor="WhiteSmoke"
                   FontSize="Large"
                   FontAttributes="Bold"
                   Margin="0,0,0,10"/>

            <Label Text="Choose the calendar system for displaying dates:"
                   TextColor="LightGray"
                   FontSize="Small"/>

            <RadioButton GroupName="CalendarGroup"
                         Content="Gregorian Calendar"
                         TextColor="WhiteSmoke"
                         IsChecked="{Binding IsGregorianSelected}" />

            <RadioButton GroupName="CalendarGroup"
                         Content="Persian (Shamsi) Calendar"
                         TextColor="WhiteSmoke"
                         IsChecked="{Binding IsPersianSelected}" />

            <!-- Separator -->
            <BoxView HeightRequest="1" Color="#333333" Margin="0,15,0,15"/>

            <!-- Data Management Section -->
            <Label Text="Data Management"
                   TextColor="WhiteSmoke"
                   FontSize="Large"
                   FontAttributes="Bold"
                   Margin="0,0,0,10"/>

            <Label Text="Export your current tasks to a JSON file or import tasks from a previously exported file (this will replace current tasks)."
                    TextColor="LightGray"
                    FontSize="Small"
                    LineBreakMode="WordWrap"/>

            <HorizontalStackLayout Spacing="10" Margin="0,10,0,0">
                <Button Text="Export Tasks"
                         Command="{Binding ExportTasksCommand}"
                         BackgroundColor="#005A9C"
                         TextColor="WhiteSmoke"/>

                <Button Text="Import Tasks"
                         Command="{Binding ImportTasksCommand}"
                         BackgroundColor="#008000"
                         TextColor="WhiteSmoke"/>
            </HorizontalStackLayout>

        </VerticalStackLayout>
    </ScrollView>

</ContentPage>

--------------------------------------------------------------------------------

// * File: Views\SettingsPage.xaml.cs---
// Views/SettingsPage.xaml.cs (New File)
namespace Tickly.Views;

public partial class SettingsPage : ContentPage
{
    public SettingsPage()
    {
        InitializeComponent();
        // BindingContext is set in XAML or via DI
    }
}

--------------------------------------------------------------------------------

